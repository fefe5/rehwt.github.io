WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:02.730
让我们通过一个例子 

00:00:02.730 --> 00:00:05.654
看看在实战中如何链接 promises

00:00:05.655 --> 00:00:08.669
这是之前的代码

00:00:08.669 --> 00:00:13.169
我们向臆造的 Web API 发起了一个请求

00:00:13.169 --> 00:00:16.829
和之前不同

00:00:16.829 --> 00:00:24.019
我们在请求成功返回后用到了 then 再发起一个 POST 请求

00:00:24.019 --> 00:00:26.375
看一下这个 POST 请求

00:00:26.375 --> 00:00:29.940
请求的路由是 addAnimal

00:00:29.940 --> 00:00:34.429
然后传入一个持有数据的对象

00:00:34.429 --> 00:00:39.740
这个对象包含两部分 一部分数据是请求 Web API 后返回的

00:00:39.740 --> 00:00:42.820
通过 then 函数直接透传进来

00:00:42.820 --> 00:00:50.094
因此直接使用 data.animal data.fact 引用

00:00:50.094 --> 00:00:55.368
这里只有一个 fav 它不是从 Web API 拿到的

00:00:55.368 --> 00:01:01.140
而是来自用户在界面上的输入

00:01:01.450 --> 00:01:04.930
再看看 postData 函数

00:01:04.930 --> 00:01:07.135
和前面的代码看起来很像

00:01:07.135 --> 00:01:13.340
依然是一个异步调用 使用 fetch 发起请求

00:01:13.340 --> 00:01:17.795
请求成功后返回数据

00:01:17.795 --> 00:01:20.555
为了弄清楚背后到底发生了什么

00:01:20.555 --> 00:01:22.655
我们看一下服务器端

00:01:22.655 --> 00:01:24.500
在服务器代码中

00:01:24.500 --> 00:01:29.870
创建了一个 POST 路由 addAnimal

00:01:29.870 --> 00:01:35.250
当在客户端代码中向这个路由发起请求时

00:01:38.379 --> 00:01:43.909
就在应用端点

00:01:43.909 --> 00:01:51.579
使用 request.body 中的数据添加了一条记录

00:01:51.579 --> 00:01:55.959
req.body 到底是什么呢

00:01:55.959 --> 00:01:59.629
我们把它打印出来看看

00:02:10.550 --> 00:02:12.750
修改了服务器端代码后

00:02:12.750 --> 00:02:15.629
要重启服务器使其生效

00:02:15.629 --> 00:02:19.750
同时刷新浏览器

00:02:19.969 --> 00:02:24.020
现在来测试一下

00:02:25.650 --> 00:02:32.819
req.body 的打印结果如下

00:02:32.819 --> 00:02:37.044
{animal: 'lion', fact: 'lions are fun', fav: 'test'}

00:02:37.044 --> 00:02:40.599
为了在应用端点新加一条记录

00:02:40.599 --> 00:02:45.085
我们使用 req.body.animal

00:02:45.085 --> 00:02:48.719
它的值是 lion req.body.fact

00:02:48.719 --> 00:02:50.069
它的值是 lions are fun

00:02:50.069 --> 00:02:53.204
req.body.fav

00:02:53.205 --> 00:02:55.830
它的值是 test

00:02:55.830 --> 00:03:01.830
然后把这条记录加入数组 animalData

00:03:02.379 --> 00:03:05.240
在这里 它是我们的

00:03:05.240 --> 00:03:09.145
API 端点 我们从这里获取数据使用

00:03:09.145 --> 00:03:18.170
让我们从服务器再回到客户端

00:03:18.169 --> 00:03:22.614
在 then 函数里

00:03:22.615 --> 00:03:28.879
post 函数会等待数据返回后再执行

00:03:28.879 --> 00:03:32.375
让我们再认真地测试一下

00:03:32.375 --> 00:03:38.900
输入 Lions are

00:03:38.900 --> 00:03:48.485
the best dinner guests for an April affair

00:03:48.485 --> 00:03:51.720
这是我最喜欢的有关狮子的趣闻

00:03:53.240 --> 00:03:56.564
然后点击 Go 按钮

00:03:56.564 --> 00:04:02.340
请求发出后

00:04:02.340 --> 00:04:03.840
从 Web API 得到的数据为

00:04:03.840 --> 00:04:07.115
{animal: 'lion', fact: 'lions are fun'}

00:04:07.115 --> 00:04:09.010
看这里

00:04:09.009 --> 00:04:11.454
从应用端点打印出的信息里

00:04:11.455 --> 00:04:13.390
还包含 fav

00:04:13.389 --> 00:04:16.339
Lions are the best dinner guests

00:04:17.269 --> 00:04:19.814
回到代码

00:04:19.814 --> 00:04:23.675
使用 then 函数

00:04:23.675 --> 00:04:29.514
我们可以在发送请求

00:04:29.514 --> 00:04:32.589
并等待其成功返回后

00:04:32.589 --> 00:04:36.329
发起另一次请求

00:04:36.329 --> 00:04:37.569
拿这个例子来说

00:04:37.569 --> 00:04:40.750
从 fakeAnimalData 拿到数据后

00:04:40.750 --> 00:04:44.615
我们使用它又发起了一个 POST 请求

00:04:44.615 --> 00:04:47.600
如果我们还想做点什么怎么办

00:04:47.600 --> 00:04:50.885
比如请求到数据并 POST 后

00:04:50.884 --> 00:04:54.829
再链接一个 promise

00:04:54.829 --> 00:04:59.069
使用 POST 后的数据更新用户界面

00:04:59.069 --> 00:05:05.389
也就是说如何在静态网页上使用动态数据

00:05:05.389 --> 00:05:09.069
且听下回分解

