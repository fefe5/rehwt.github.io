WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:02.940
这一视频将介绍 Sass

00:00:02.940 --> 00:00:06.000
以及为什么 Sass 是一个出色的前端工具

00:00:06.000 --> 00:00:10.785
官方文档称自己是 CSS 的扩展语言

00:00:10.785 --> 00:00:12.554
这句话可能会让人有些困惑

00:00:12.554 --> 00:00:14.265
Sass 到底是什么?

00:00:14.265 --> 00:00:20.039
Sass 实际上是出色的 CSS 扩展语法集合 能帮助你编写更好

00:00:20.039 --> 00:00:24.210
更清晰和高效的样式

00:00:24.210 --> 00:00:27.469
这是非常值得学习的

00:00:27.469 --> 00:00:32.464
主要也因为它是前端开发中很常用的工具

00:00:32.465 --> 00:00:34.250
在某些面试中

00:00:34.250 --> 00:00:36.409
你可能会遇到关于 Sass 的问题

00:00:36.409 --> 00:00:40.459
并且我敢保证你肯定会在某些时候遇到 Sass 样式表

00:00:40.460 --> 00:00:42.605
所以学习这一工具会很方便

00:00:42.604 --> 00:00:48.444
这真的是编写更好 CSS 语法的强力工具

00:00:48.445 --> 00:00:54.564
接下来讨论一下 为什么需要 webpack 来运行 CSS 和 Sass?

00:00:54.564 --> 00:01:01.250
我们知道自己在浏览器上使用过 CSS 并不需要 webpack

00:01:01.250 --> 00:01:02.840
所以问题是

00:01:02.840 --> 00:01:08.260
Sass 有何不同 以至于需要 webpack 来运行样式?

00:01:08.260 --> 00:01:12.050
这似乎有点奇怪 除非我们认识到

00:01:12.049 --> 00:01:17.045
因特网处理 HTML 中样式的原理

00:01:17.045 --> 00:01:19.799
我们总是从客户端启动

00:01:19.799 --> 00:01:22.034
在客户端或浏览器上

00:01:22.034 --> 00:01:25.325
可以运行 HTML、CSS 和 JavaScript

00:01:25.325 --> 00:01:29.405
但是当客户端向服务器发出请求时

00:01:29.405 --> 00:01:33.000
如果服务器使用 Sass 而不是 CSS

00:01:33.000 --> 00:01:36.390
它会尝试将 Sass 发送给客户端

00:01:36.390 --> 00:01:39.480
但是浏览器不知道 Sass 是什么

00:01:39.480 --> 00:01:44.070
应用的这一端不能出现任何 Sass

00:01:44.069 --> 00:01:47.563
因此 当我们在服务端时

00:01:47.563 --> 00:01:52.519
可以使用 webpack 来处理 Sass 文件

00:01:52.519 --> 00:01:58.054
将其转换为 CSS 这样就可以将 CSS 发送给客户端

00:01:58.055 --> 00:02:02.780
理解整个过程是很重要的

00:02:02.780 --> 00:02:07.780
每当使用像 less 或 Sass 这样的 CSS 预处理库时

00:02:07.780 --> 00:02:10.814
它们在前端开发中真的很常用

00:02:10.814 --> 00:02:12.944
你都始终需要构建步骤

00:02:12.944 --> 00:02:16.489
这也是我们使用构建工具的主要原因之一

00:02:16.490 --> 00:02:21.004
Grunt、Gulp 和 webpack 都是很常见的

00:02:21.004 --> 00:02:27.060
可以在服务端将 Sass 转换为 CSS 然后再发送到客户端的构建工具

